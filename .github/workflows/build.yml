# BrainDock Build Workflow
#
# Automatically builds macOS and Windows executables when a version tag is pushed.
# Signs and notarizes macOS builds for Gatekeeper approval.
# Uploads the built artifacts to GitHub Releases.
#
# Usage:
#   1. Set these GitHub Secrets (Settings > Secrets > Actions):
#      - GEMINI_API_KEY (required)
#      - OPENAI_API_KEY (optional, for fallback/alternative AI)
#      - STRIPE_SECRET_KEY (optional, for payments)
#      - STRIPE_PUBLISHABLE_KEY (optional, for payments)
#      - STRIPE_PRICE_ID (optional, for payments)
#      - APPLE_CERTIFICATE_BASE64 (required for macOS signing)
#      - APPLE_CERTIFICATE_PASSWORD (required for macOS signing)
#      - APPLE_ID (required for macOS notarization)
#      - APPLE_APP_SPECIFIC_PASSWORD (required for macOS notarization)
#      - APPLE_TEAM_ID (required for macOS notarization)
#      - WINDOWS_CERTIFICATE_BASE64 (optional - for Windows code signing)
#      - WINDOWS_CERTIFICATE_PASSWORD (optional - for Windows code signing)
#   2. Push a tag: git tag v1.0.0 && git push origin v1.0.0
#   3. The workflow will build, sign, notarize, and create a release
#
# The release will contain:
#   - BrainDock-macOS.dmg (signed & notarized macOS installer)
#   - BrainDock-Setup.exe (Windows installer, signed if certificate configured)

name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0, v1.2.3, etc.
  workflow_dispatch:  # Allow manual trigger from GitHub UI
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        default: 'v1.0.0-test'

env:
  PYTHON_VERSION: '3.11'

jobs:
  # Build macOS app (signed and notarized)
  build-macos:
    runs-on: macos-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
      
      - name: Install create-dmg
        run: brew install create-dmg
      
      - name: Generate icons
        run: python build/create_icons.py
      
      - name: Generate bundled keys module
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          STRIPE_PRICE_ID: ${{ secrets.STRIPE_PRICE_ID }}
        shell: python
        run: |
          import os
          
          def get_clean_key(env_var):
              """Get env var, strip whitespace, escape for Python string literal."""
              value = os.environ.get(env_var, '').strip()
              if not value:
                  return ''
              # Escape backslashes, quotes, and newlines for safe Python string
              return value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r')
          
          # Get and escape all keys
          keys = {
              'OPENAI_API_KEY': get_clean_key('OPENAI_API_KEY'),
              'GEMINI_API_KEY': get_clean_key('GEMINI_API_KEY'),
              'STRIPE_SECRET_KEY': get_clean_key('STRIPE_SECRET_KEY'),
              'STRIPE_PUBLISHABLE_KEY': get_clean_key('STRIPE_PUBLISHABLE_KEY'),
              'STRIPE_PRICE_ID': get_clean_key('STRIPE_PRICE_ID'),
          }
          
          # Generate bundled_keys.py (imported by config.py at runtime)
          with open('bundled_keys_template.py', 'r') as f:
              content = f.read()
          for key_name, key_value in keys.items():
              content = content.replace(f'%%{key_name}%%', key_value)
          with open('bundled_keys.py', 'w') as f:
              f.write(content)
          print("bundled_keys.py generated with embedded keys")
      
      - name: Build with PyInstaller
        run: |
          pyinstaller build/braindock.spec --noconfirm
      
      - name: Install Apple Developer Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          
          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Verify certificate is installed
          security find-identity -v -p codesigning $KEYCHAIN_PATH
          
          # Clean up
          rm $RUNNER_TEMP/certificate.p12
      
      - name: Sign app bundle
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          IDENTITY="Developer ID Application: Morayya Jain ($APPLE_TEAM_ID)"
          ENTITLEMENTS="build/entitlements.plist"
          
          echo "Signing with identity: $IDENTITY"
          echo "Finding and signing all Mach-O binaries..."
          
          # Find and sign ALL Mach-O binaries (dylib, so, executables)
          # Use proper grouping for find command
          find dist/BrainDock.app -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.bundle" \) | while read -r file; do
            echo "Signing: $file"
            codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$IDENTITY" \
              "$file"
          done
          
          # Sign all frameworks (directories)
          find dist/BrainDock.app -type d -name "*.framework" | while read -r framework; do
            echo "Signing framework: $framework"
            codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$IDENTITY" \
              "$framework"
          done
          
          # Sign Python and other executables
          find dist/BrainDock.app -type f -perm +111 ! -name "*.dylib" ! -name "*.so" | while read -r file; do
            # Check if it's a Mach-O binary
            if file "$file" | grep -q "Mach-O"; then
              echo "Signing executable: $file"
              codesign --force --options runtime --timestamp \
                --entitlements "$ENTITLEMENTS" \
                --sign "$IDENTITY" \
                "$file"
            fi
          done
          
          # Sign the main executable explicitly
          echo "Signing main executable..."
          codesign --force --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS" \
            --sign "$IDENTITY" \
            "dist/BrainDock.app/Contents/MacOS/BrainDock"
          
          # Deep sign the entire app bundle as final step
          echo "Deep signing entire app bundle..."
          codesign --force --deep --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS" \
            --sign "$IDENTITY" \
            "dist/BrainDock.app"
          
          # Verify signature thoroughly
          echo "Verifying signature..."
          codesign --verify --verbose=2 --deep --strict dist/BrainDock.app
          
          # Check for unsigned code
          echo "Checking for any unsigned code..."
          codesign --verify --deep --strict dist/BrainDock.app 2>&1 || {
            echo "WARNING: Some components may not be properly signed"
            # List any unsigned binaries
            find dist/BrainDock.app -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -exec sh -c 'codesign -v "$1" 2>/dev/null || echo "Unsigned: $1"' _ {} \;
          }
          
          echo "App signed successfully!"
      
      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        timeout-minutes: 60
        run: |
          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent dist/BrainDock.app dist/BrainDock-notarize.zip
          
          echo "ZIP file size:"
          ls -lh dist/BrainDock-notarize.zip
          
          echo "Submitting to Apple notarization service..."
          
          # Submit and capture the submission ID
          SUBMIT_OUTPUT=$(xcrun notarytool submit dist/BrainDock-notarize.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 55m 2>&1) || {
            echo "Notarization failed or timed out"
            echo "$SUBMIT_OUTPUT"
            
            # Extract submission ID if available
            SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o 'id: [a-f0-9-]*' | head -1 | cut -d' ' -f2)
            if [ -n "$SUBMISSION_ID" ]; then
              echo "Fetching notarization log for submission: $SUBMISSION_ID"
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi
            exit 1
          }
          
          echo "$SUBMIT_OUTPUT"
          
          # Check if notarization was accepted
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization accepted!"
          else
            echo "Notarization may have issues, checking log..."
            SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o 'id: [a-f0-9-]*' | head -1 | cut -d' ' -f2)
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi
          fi
          
          echo "Stapling notarization ticket..."
          xcrun stapler staple dist/BrainDock.app
          
          echo "Notarization complete!"
          rm dist/BrainDock-notarize.zip
      
      - name: Create signed DMG
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        timeout-minutes: 60
        run: |
          IDENTITY="Developer ID Application: Morayya Jain ($APPLE_TEAM_ID)"
          
          # Generate DMG background if it doesn't exist
          if [ ! -f "build/dmg_background.png" ]; then
            python build/create_dmg_background.py
          fi
          
          # Create DMG using create-dmg
          echo "Creating DMG..."
          create-dmg \
            --volname "BrainDock" \
            --volicon "build/icon.icns" \
            --background "build/dmg_background.png" \
            --window-pos 200 120 \
            --window-size 660 400 \
            --icon-size 100 \
            --icon "BrainDock.app" 180 190 \
            --hide-extension "BrainDock.app" \
            --app-drop-link 480 190 \
            --no-internet-enable \
            "dist/BrainDock-macOS.dmg" \
            "dist/BrainDock.app"
          
          echo "DMG file size:"
          ls -lh dist/BrainDock-macOS.dmg
          
          # Sign the DMG
          echo "Signing DMG..."
          codesign --force --timestamp \
            --sign "$IDENTITY" \
            "dist/BrainDock-macOS.dmg"
          
          # Verify DMG signature
          codesign --verify --verbose dist/BrainDock-macOS.dmg
          
          # Notarize the DMG with timeout
          echo "Notarizing DMG..."
          xcrun notarytool submit dist/BrainDock-macOS.dmg \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 55m || {
            echo "DMG notarization failed or timed out"
            exit 1
          }
          
          # Staple the DMG
          echo "Stapling DMG..."
          xcrun stapler staple dist/BrainDock-macOS.dmg
          
          echo "DMG created, signed, and notarized!"
      
      - name: Upload macOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: BrainDock-macOS
          path: dist/BrainDock-macOS.dmg
          if-no-files-found: error

  # Build Windows app
  build-windows:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get version from tag
        id: get_version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          # Remove 'v' prefix for installer version (v1.0.0 -> 1.0.0)
          VERSION_NUM="${VERSION#v}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION_NUM=$VERSION_NUM" >> $GITHUB_OUTPUT
          echo "Version: $VERSION (numeric: $VERSION_NUM)"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller
      
      - name: Install Inno Setup
        run: |
          choco install innosetup -y
      
      - name: Generate icons
        run: python build/create_icons.py
      
      - name: Generate bundled keys module
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          STRIPE_PRICE_ID: ${{ secrets.STRIPE_PRICE_ID }}
        shell: python
        run: |
          import os
          
          def get_clean_key(env_var):
              """Get env var, strip whitespace, escape for Python string literal."""
              value = os.environ.get(env_var, '').strip()
              if not value:
                  return ''
              # Escape backslashes, quotes, and newlines for safe Python string
              return value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r')
          
          # Get and escape all keys
          keys = {
              'OPENAI_API_KEY': get_clean_key('OPENAI_API_KEY'),
              'GEMINI_API_KEY': get_clean_key('GEMINI_API_KEY'),
              'STRIPE_SECRET_KEY': get_clean_key('STRIPE_SECRET_KEY'),
              'STRIPE_PUBLISHABLE_KEY': get_clean_key('STRIPE_PUBLISHABLE_KEY'),
              'STRIPE_PRICE_ID': get_clean_key('STRIPE_PRICE_ID'),
          }
          
          # Generate bundled_keys.py (imported by config.py at runtime)
          with open('bundled_keys_template.py', 'r') as f:
              content = f.read()
          for key_name, key_value in keys.items():
              content = content.replace(f'%%{key_name}%%', key_value)
          with open('bundled_keys.py', 'w') as f:
              f.write(content)
          print("bundled_keys.py generated with embedded keys")
      
      - name: Build with PyInstaller
        run: |
          pyinstaller build/braindock.spec --noconfirm
      
      - name: Update installer version
        shell: python
        run: |
          version = "${{ steps.get_version.outputs.VERSION_NUM }}"
          with open('build/installer.iss', 'r') as f:
              content = f.read()
          content = content.replace('#define MyAppVersion "1.0.0"', 
                                    f'#define MyAppVersion "{version}"')
          with open('build/installer.iss', 'w') as f:
              f.write(content)
          print(f"Updated installer version to {version}")
      
      - name: Build Windows Installer
        run: |
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" build\installer.iss
      
      - name: Sign Windows Installer (Optional)
        env:
          WINDOWS_CERTIFICATE_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_BASE64 }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          # Check if certificate is configured - skip if not
          if ([string]::IsNullOrEmpty($env:WINDOWS_CERTIFICATE_BASE64)) {
            Write-Host "No Windows certificate configured, skipping code signing" -ForegroundColor Yellow
            Write-Host "To enable signing, add WINDOWS_CERTIFICATE_BASE64 and WINDOWS_CERTIFICATE_PASSWORD secrets"
            exit 0
          }
          
          Write-Host "Certificate found, signing installer..." -ForegroundColor Green
          
          # Decode certificate
          $certBytes = [Convert]::FromBase64String($env:WINDOWS_CERTIFICATE_BASE64)
          $certPath = "$env:RUNNER_TEMP\certificate.pfx"
          [IO.File]::WriteAllBytes($certPath, $certBytes)
          
          # Find signtool dynamically (SDK version varies on runners)
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                      Where-Object { $_.FullName -match "x64" } | 
                      Sort-Object { $_.Directory.Name } -Descending |
                      Select-Object -First 1 -ExpandProperty FullName
          
          if (-not $signtool) {
            Write-Error "signtool.exe not found in Windows SDK"
            Remove-Item $certPath -Force -ErrorAction SilentlyContinue
            exit 1
          }
          
          Write-Host "Using signtool: $signtool"
          
          # Sign the installer
          & $signtool sign /f $certPath /p $env:WINDOWS_CERTIFICATE_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 /d "BrainDock" "dist\BrainDock-Setup.exe"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Signing failed with exit code $LASTEXITCODE"
            Remove-Item $certPath -Force -ErrorAction SilentlyContinue
            exit 1
          }
          
          # Clean up
          Remove-Item $certPath -Force
          
          Write-Host "Installer signed successfully!" -ForegroundColor Green
      
      - name: Upload Windows artifact
        uses: actions/upload-artifact@v4
        with:
          name: BrainDock-Windows
          path: dist/BrainDock-Setup.exe
          if-no-files-found: error

  # Create GitHub Release with both artifacts
  release:
    needs: [build-macos, build-windows]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download macOS artifact
        uses: actions/download-artifact@v4
        with:
          name: BrainDock-macOS
          path: ./release
      
      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: BrainDock-Windows
          path: ./release
      
      - name: Get version from tag
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          name: BrainDock ${{ steps.get_version.outputs.VERSION }}
          body: |
            ## BrainDock ${{ steps.get_version.outputs.VERSION }}
            
            ### Downloads
            
            | Platform | Download |
            |----------|----------|
            | macOS | [BrainDock-macOS.dmg](https://github.com/${{ github.repository }}/releases/download/${{ steps.get_version.outputs.VERSION }}/BrainDock-macOS.dmg) |
            | Windows | [BrainDock-Setup.exe](https://github.com/${{ github.repository }}/releases/download/${{ steps.get_version.outputs.VERSION }}/BrainDock-Setup.exe) |
            
            ### Installation Instructions
            
            **macOS:** (Signed & Notarized - No Gatekeeper warnings!)
            1. Download and double-click the DMG file
            2. Drag BrainDock to the Applications folder
            3. Eject the DMG
            4. Open BrainDock from Applications
            
            **Windows:**
            1. Download and run BrainDock-Setup.exe
            2. Follow the installation wizard
            3. Launch BrainDock from Start Menu or Desktop
            4. If SmartScreen appears, click "More info" then "Run anyway"
            
            ### Requirements
            - A webcam for focus monitoring
            - Internet connection for AI-powered detection
          draft: false
          prerelease: ${{ contains(steps.get_version.outputs.VERSION, '-') }}
          files: |
            ./release/BrainDock-macOS.dmg
            ./release/BrainDock-Setup.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
